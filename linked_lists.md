### Связный список

Продолжаем тему структур данных. На этот раз речь пойдет о **связном списке**.

**Связный список** - структура данных, которая хранит множество объектов в линейном порядке, где доступ к элементам осуществляется через соседние элементы. 
В отличие от массивов:
- более гибкая структура, т.к. порядок обхода задан самими элементами
- может хранить объекты разного типа
- объекты могут хранится на разных участках памяти  
- менее эффективный доступ к порядковому элементу (в списке O(n) vs в массиве O(1))

#### Определения
**Узел** - элемент списка, хранящий значение(ключ) и ссылки на соседние элементы

**Односвязный список** - список, где в каждом узле хранится ссылка только на следующий или только на предыдущий элемент

**Двусвязный список** - список, в котором в каждом узле хранятся ссылки на следующий и предыдущий элементы.


**Кольцевой(циклический) список** - список, в котором хвост списка связан с головой

#### Реализация двусвязного списка

Создадим класс узла - **ListNode**, с аттрибутами **key**(ключ), 
**next**(ссылка на следующий узел), **prev**(ссылка на предыдущий узел).
А так же класс самого списка -  **LinkedList**, в котором будем хранить ссылку на первый элемент списка, т.е. на голову(**head**).

Реализуем три основных операции insert(вставка ключа), search(поиск по ключу), delete(удаление узла):

- Операция **insert**:
Создаем новый узел. Указывем следующим(**next**) узлом текущую голову(**head**). У текущей головы, предыдущим(**prev**) узлом указываем новый узел. И в заключении, делаем наш новый узел головой списка.

- Операция **search**:
Последовательно, от начала списка, при помощи ссылки **next** итерируем по всему списку, пока не наткнемся на нужный ключ. 

- Операция **delete**:
Связываем предыдущий и следующий узлы между собой, таким образом узел между ними будет удален из списка. 
Если у удаляемого узла нету предыдущего элемента, т.е. он является головой, необходимо, чтобы теперь голова указывала на следующий элемент.

```python
# Linked List

class ListNode:
    def __init__(self, key, prev=None, _next=None):
        self.key = key
        self.next = _next
        self.prev = prev


class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, key):
        new = ListNode(key, _next=self.head)
        if self.head:
            self.head.prev = new
        self.head = new

    def search(self, key):
        cur = self.head
        while cur and cur.key != key:
            cur = cur.next
        return cur

    def delete(self, node):
        if node.prev:
            node.prev.next = node.next
        else:
            self.head = node.next
        if node.next:
            node.next.prev = node.prev
```

##### Ограничитель(Sentinel)
Можно вместо хранения ссылки на начальный элемент(**head**), использовать узел ограничитель(sentinel). 
Узел ограничитель это узел-болванка соединяющая конец и начало списка, делая его кольцевым.
Это займет чуть больше памяти, но делает код чуть проще, за счет того, что не нужно проверять граничные случаи.



```python
# Linked List with Sentinel

class ListNode:
    def __init__(self, key, prev=None, _next=None):
        self.key = key
        self.next = _next
        self.prev = prev


class LinkedListWithSentinel:
    def __init__(self):
        self.nil = ListNode(key=None)  # Sentinel

    def insert(self, key):
        new = ListNode(key, _next=self.nil.next)
        new.prev = self.nil
        self.nil.next = new

    def search(self, key):
        cur = self.nil.next
        while cur and cur.key != key:
            cur = cur.next
        return cur

    def delete(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
```