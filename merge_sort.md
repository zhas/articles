Существует большое количество алгоритмов, предназначенных для сортировки последовательностей, но среди них не очень много алгоритмов обладающих хорошим быстродействием и гибкостью. В данной статье будет разобрана **сортировка слиянием**, которая имеет хорошую асимптотическую сложность O(N*log(N)) и хорошую гибкость, вследствие чего часто применяется на практике. 

<p style="text-align: center">
<img src="https://raw.githubusercontent.com/zhas/articles/master/images/merge_sort_1.png">
</p>

## Описание алгоритма

Данный алгоритм состоит из трех этапов:

1) **разделение** исходной последовательности на две части пополам
2) сортировки каждой из этих частей, этим же алгоритмом слияния(т.е. **рекурсивный вызов**)
3) **слияние** двух отсортированных последовательностей в одну отсортированную последовательность

Такой подход, когда решение задачи разбивается на рекурсивное решение подзадач такого же типа, как и исходная задача, называется подходом **разделяй и властвуй**. 

Разберем каждый из этапов подробнее:

1. **Разделение**

    Для того, чтобы разделить последовательность, достаточно выбрать элемент посередине middle, и представить две последовательности в виде отрезков [left, middle) , [middle, right).


2. **Рекурсия**

    Для каждого отрезка рекурсивно запускаем сортировку. Рекурсию заканчиваем в том случае, если количество элементов стало <= 1, ведь пустая последовательность и последовательность с одним элементом является отсортированной.


3. **Слияние**

    После того, как последовательность была разбита на две части и обе части были отсортированы, наступило время для их слияния. Этот шаг является ключевым в алгоритме сортировки слиянием. Суть состоит в том, чтобы по очереди брать из каждой последовательности по одному элементу, и наименьший из них складывать в итоговую последовательность,  другой же элемент использовать для следующего сравнения.

    Пример слияния последовательностей [3, 4, 7] и  [5, 6]
    1. Берем 3 и 5, так как 3 меньше 5, складываем её в результат -> [3]
    2. Берем следующий элемент из первой последовательности - 4, и сравниваем его с 5, т.к. 4 < 5 , складываем 4 в результат -> [3, 4]
    3. Берем следующий элемент из первой последовательности - 7, и сравниваем его с 5, т.к. 5 < 7 , складываем 5 в результат -> [3, 4, 5]
    4. Берем следующий элемент из второй последовательности - 6, и сравниваем его с 7, т.к. 6 < 7 , складываем 6 в результат -> [3, 4, 5, 6]
    5. Так как у нас осталось, только 7 складываем её в результат [3,4,5,6,7]

На картинке ниже можно увидеть полный цикл сортировки слиянием, на примере последовательности [3,4,2,1,2,6,4]:

<p style="text-align: center">
<img src="https://raw.githubusercontent.com/zhas/articles/master/images/merge_sort_2.png">
</p>

## Оценка сложности алгоритма

Для того чтобы сделать слияние двух отсортированных последовательностей в одну отсортированную последовательность, нам необходимо перебрать все элементы, т.е. сложность будет равна O(N), где N сумма элементов двух последовательностей.

На картинке выше, можно увидеть проход по дереву рекурсии. В первой половине, во время **разделения** - мы идем вниз по дереву, во время **слияния** - вверх по дереву. Так как на каждом шаге, мы делим последовательность на две части, глубина дерева рекурсии будет log(N). На каждом уровне рекурсии, нам необходимо слить примерно N элементов, и как мы уже знаем, это будет иметь сложность O(N). Следовательно, сложность алгоритма слияния будет O(N*log(N)).

## Реализация 
Для начала реализуем функцию **merge_sort**, принимающую в себя список **numbers**, и его границы **[l, r)**. В случае количества элементов <= 1 выходим из функции, ведь такой список уже отсортирован. Затем рекурсивно запускаем **merge_sort** для обеих последовательностей, и в итоге сливаем их в одну функцией **merge**. 

Функция **merge** принимает в себя список **numbers**, и границы двух последовательностей **l**, **m**, **r**. Реализованная функция следуют алгоритму слияния описанного выше. Заводится специальный буфер(**buf**) куда будет складываться результат слияния, и по указателю на каждую последовательность. Затем запускается цикл на **(r - l)** шагов, и на каждом шаге заполняется буфер. В случае если одна из последовательностей достигла конца, то берется элемент из другой последовательности, иначе сравниваются два элемента и берется наименьший. В конце все элементы из буфера копируются в исходный список.

```python
# Merge sort. Divide and conquer

def merge(numbers, l, m, r):
    n = r - l
    buf = [0] * n

    i, j = l, m

    for k in range(n):
        if i == m:
            buf[k] = numbers[j]
            j += 1
        elif j == r:
            buf[k] = numbers[i]
            i += 1
        elif numbers[i] < numbers[j]:
            buf[k] = numbers[i]
            i += 1
        else:
            buf[k] = numbers[j]
            j += 1

    for k in range(n):
        numbers[l + k] = buf[k]


def merge_sort(numbers, l, r):
    if (r - l) <= 1:
        return

    m = (l + r) // 2

    merge_sort(numbers, l, m)
    merge_sort(numbers, m, r)
    merge(numbers, l, m, r)
```

Условия в функции слияния можно реализовать более компактно, но в таком случае код будет менее интуитивным:

```python
def merge(numbers, l, m, r):
    n = r - l
    buf = [0] * n

    i, j = l, m

    for k in range(n):
        if i == m or (j != r and numbers[i] > numbers[j]):
            buf[k] = numbers[j]
            j += 1
        elif j == r:
            buf[k] = numbers[i]
            i += 1

    for k in range(n):
        numbers[l + k] = buf[k]
```

## Заключение

**Сортировка слиянием** - отличный алгоритм сортировки, который имеет сложность в худшем случае O(Nlog(N)). Как и быстрая сортировка(quick sort), часто этот алгоритм применяется в качестве стандартного алгоритма сортировки, например в java он используется для сортировки коллекций, а в python встроенной сортировкой является алгоритм timsort, который в свою очередь базируется на сортировке слиянием. Помимо хорошей асимптотики, плюсом сортировки является её гибкость, устойчивость и хорошее распараллеливание. А минусом - использование дополнительной памяти.


## Используемая литература
* Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы. Построение и анализ.
* [ru.wikipedia.org](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)